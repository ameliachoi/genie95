{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar DEFAULT_DRAG_THRESHOLD = {\n  delay: 0,\n  distance: 3\n  /* DISTANCE */\n};\nfunction draggable(node, options = {}) {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = false,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    threshold = DEFAULT_DRAG_THRESHOLD,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = {\n      x: 0,\n      y: 0\n    },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let is_interacting = false;\n  let is_dragging = false;\n  let start_time = 0;\n  let meets_time_threshold = false;\n  let meets_distance_threshold = false;\n  let translate_x = 0,\n    translate_y = 0;\n  let initial_x = 0,\n    initial_y = 0;\n  let client_to_node_offsetX = 0,\n    client_to_node_offsetY = 0;\n  let {\n    x: x_offset,\n    y: y_offset\n  } = position ? {\n    x: position?.x ?? 0,\n    y: position?.y ?? 0\n  } : defaultPosition;\n  set_translate(x_offset, y_offset);\n  let can_move_in_x;\n  let can_move_in_y;\n  let body_original_user_select_val = \"\";\n  let computed_bounds;\n  let node_rect;\n  let drag_els;\n  let cancel_els;\n  let currently_dragged_el;\n  let is_controlled = !!position;\n  recomputeBounds = {\n    ...DEFAULT_RECOMPUTE_BOUNDS,\n    ...recomputeBounds\n  };\n  threshold = {\n    ...DEFAULT_DRAG_THRESHOLD,\n    ...(threshold ?? {})\n  };\n  let active_pointers = /* @__PURE__ */new Set();\n  function try_start_drag(event) {\n    if (is_interacting && !is_dragging && meets_distance_threshold && meets_time_threshold && currently_dragged_el) {\n      is_dragging = true;\n      fire_svelte_drag_start_event(event);\n      node_class_list.add(defaultClassDragging);\n      if (applyUserSelectHack) {\n        body_original_user_select_val = body_style.userSelect;\n        body_style.userSelect = \"none\";\n      }\n    }\n  }\n  function reset_state() {\n    is_dragging = false;\n    meets_time_threshold = false;\n    meets_distance_threshold = false;\n  }\n  const body_style = document.body.style;\n  const node_class_list = node.classList;\n  function set_translate(x_pos = translate_x, y_pos = translate_y) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+x_pos}px, ${+y_pos}px`;\n        return set_style(node, \"transform\", gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`);\n      }\n      return set_style(node, \"translate\", `${+x_pos}px ${+y_pos}px`);\n    }\n    const transform_called = transform({\n      offsetX: x_pos,\n      offsetY: y_pos,\n      rootNode: node\n    });\n    if (is_string(transform_called)) {\n      set_style(node, \"transform\", transform_called);\n    }\n  }\n  function get_event_data(event) {\n    return {\n      offsetX: translate_x,\n      offsetY: translate_y,\n      rootNode: node,\n      currentNode: currently_dragged_el,\n      event\n    };\n  }\n  function call_event(eventName, fn, event) {\n    const data = get_event_data(event);\n    node.dispatchEvent(new CustomEvent(eventName, {\n      detail: data\n    }));\n    fn?.(data);\n  }\n  function fire_svelte_drag_start_event(event) {\n    call_event(\"neodrag:start\", onDragStart, event);\n  }\n  function fire_svelte_drag_end_event(event) {\n    call_event(\"neodrag:end\", onDragEnd, event);\n  }\n  function fire_svelte_drag_event(event) {\n    call_event(\"neodrag\", onDrag, event);\n  }\n  const listen = addEventListener;\n  const controller = new AbortController();\n  const event_options = {\n    signal: controller.signal,\n    capture: false\n  };\n  set_style(node, \"touch-action\", \"none\");\n  listen(\"pointerdown\", e => {\n    if (disabled) return;\n    if (e.button === 2) return;\n    active_pointers.add(e.pointerId);\n    if (ignoreMultitouch && active_pointers.size > 1) return e.preventDefault();\n    if (recomputeBounds.dragStart) computed_bounds = compute_bound_rect(bounds, node);\n    if (is_string(handle) && is_string(cancel) && handle === cancel) throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n    node_class_list.add(defaultClass);\n    drag_els = get_handle_els(handle, node);\n    cancel_els = get_cancel_elements(cancel, node);\n    can_move_in_x = /(both|x)/.test(axis);\n    can_move_in_y = /(both|y)/.test(axis);\n    if (cancel_element_contains(cancel_els, drag_els)) throw new Error(\"Element being dragged can't be a child of the element on which `cancel` is applied\");\n    const event_target = e.composedPath()[0];\n    if (drag_els.some(el => el.contains(event_target) || el.shadowRoot?.contains(event_target)) && !cancel_element_contains(cancel_els, [event_target])) {\n      currently_dragged_el = drag_els.length === 1 ? node : drag_els.find(el => el.contains(event_target));\n      is_interacting = true;\n      start_time = Date.now();\n      if (!threshold.delay) {\n        meets_time_threshold = true;\n      }\n    } else return;\n    node_rect = node.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = e;\n    const inverse_scale = calculate_inverse_scale();\n    if (can_move_in_x) initial_x = clientX - x_offset / inverse_scale;\n    if (can_move_in_y) initial_y = clientY - y_offset / inverse_scale;\n    if (computed_bounds) {\n      client_to_node_offsetX = clientX - node_rect.left;\n      client_to_node_offsetY = clientY - node_rect.top;\n    }\n  }, event_options);\n  listen(\"pointermove\", e => {\n    if (!is_interacting || ignoreMultitouch && active_pointers.size > 1) return;\n    if (!is_dragging) {\n      if (!meets_time_threshold) {\n        const elapsed = Date.now() - start_time;\n        if (elapsed >= threshold.delay) {\n          meets_time_threshold = true;\n          try_start_drag(e);\n        }\n      }\n      if (!meets_distance_threshold) {\n        const delta_x = e.clientX - initial_x;\n        const delta_y = e.clientY - initial_y;\n        const distance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n        if (distance >= threshold.distance) {\n          meets_distance_threshold = true;\n          try_start_drag(e);\n        }\n      }\n      if (!is_dragging) return;\n    }\n    if (recomputeBounds.drag) computed_bounds = compute_bound_rect(bounds, node);\n    e.preventDefault();\n    node_rect = node.getBoundingClientRect();\n    let final_x = e.clientX,\n      final_y = e.clientY;\n    const inverse_scale = calculate_inverse_scale();\n    if (computed_bounds) {\n      const virtual_client_bounds = {\n        left: computed_bounds.left + client_to_node_offsetX,\n        top: computed_bounds.top + client_to_node_offsetY,\n        right: computed_bounds.right + client_to_node_offsetX - node_rect.width,\n        bottom: computed_bounds.bottom + client_to_node_offsetY - node_rect.height\n      };\n      final_x = clamp(final_x, virtual_client_bounds.left, virtual_client_bounds.right);\n      final_y = clamp(final_y, virtual_client_bounds.top, virtual_client_bounds.bottom);\n    }\n    if (Array.isArray(grid)) {\n      let [x_snap, y_snap] = grid;\n      if (isNaN(+x_snap) || x_snap < 0) throw new Error(\"1st argument of `grid` must be a valid positive number\");\n      if (isNaN(+y_snap) || y_snap < 0) throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n      let delta_x = final_x - initial_x,\n        delta_y = final_y - initial_y;\n      [delta_x, delta_y] = snap_to_grid([x_snap / inverse_scale, y_snap / inverse_scale], delta_x, delta_y);\n      final_x = initial_x + delta_x;\n      final_y = initial_y + delta_y;\n    }\n    if (can_move_in_x) translate_x = Math.round((final_x - initial_x) * inverse_scale);\n    if (can_move_in_y) translate_y = Math.round((final_y - initial_y) * inverse_scale);\n    x_offset = translate_x;\n    y_offset = translate_y;\n    fire_svelte_drag_event(e);\n    set_translate();\n  }, event_options);\n  listen(\"pointerup\", e => {\n    active_pointers.delete(e.pointerId);\n    if (!is_interacting) return;\n    if (is_dragging) {\n      listen(\"click\", e2 => e2.stopPropagation(), {\n        once: true,\n        signal: controller.signal,\n        capture: true\n      });\n      if (recomputeBounds.dragEnd) computed_bounds = compute_bound_rect(bounds, node);\n      node_class_list.remove(defaultClassDragging);\n      node_class_list.add(defaultClassDragged);\n      if (applyUserSelectHack) body_style.userSelect = body_original_user_select_val;\n      fire_svelte_drag_end_event(e);\n      if (can_move_in_x) initial_x = translate_x;\n      if (can_move_in_y) initial_y = translate_y;\n    }\n    is_interacting = false;\n    reset_state();\n  }, event_options);\n  function calculate_inverse_scale() {\n    let inverse_scale = node.offsetWidth / node_rect.width;\n    if (isNaN(inverse_scale)) inverse_scale = 1;\n    return inverse_scale;\n  }\n  return {\n    destroy: () => controller.abort(),\n    update: options2 => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? true;\n      transform = options2.transform;\n      threshold = {\n        ...DEFAULT_DRAG_THRESHOLD,\n        ...(options2.threshold ?? {})\n      };\n      const dragged = node_class_list.contains(defaultClassDragged);\n      node_class_list.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      node_class_list.add(defaultClass);\n      if (dragged) node_class_list.add(defaultClassDragged);\n      if (is_controlled) {\n        x_offset = translate_x = options2.position?.x ?? translate_x;\n        y_offset = translate_y = options2.position?.y ?? translate_y;\n        set_translate();\n      }\n    }\n  };\n}\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar is_string = val => typeof val === \"string\";\nvar snap_to_grid = ([x_snap, y_snap], pending_x, pending_y) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pending_x, x_snap);\n  const y = calc(pending_y, y_snap);\n  return [x, y];\n};\nfunction get_handle_els(handle, node) {\n  if (!handle) return [node];\n  if (is_HTMLElement(handle)) return [handle];\n  if (Array.isArray(handle)) return handle;\n  const handle_els = node.querySelectorAll(handle);\n  if (handle_els === null) throw new Error(\"Selector passed for `handle` option should be child of the element on which the action is applied\");\n  return Array.from(handle_els.values());\n}\nfunction get_cancel_elements(cancel, node) {\n  if (!cancel) return [];\n  if (is_HTMLElement(cancel)) return [cancel];\n  if (Array.isArray(cancel)) return cancel;\n  const cancel_els = node.querySelectorAll(cancel);\n  if (cancel_els === null) throw new Error(\"Selector passed for `cancel` option should be child of the element on which the action is applied\");\n  return Array.from(cancel_els.values());\n}\nvar cancel_element_contains = (cancel_elements, drag_elements) => cancel_elements.some(cancelEl => drag_elements.some(el => cancelEl.contains(el)));\nfunction compute_bound_rect(bounds, rootNode) {\n  if (bounds === void 0) return;\n  if (is_HTMLElement(bounds)) return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const {\n      top = 0,\n      left = 0,\n      right = 0,\n      bottom = 0\n    } = bounds;\n    const computed_right = window.innerWidth - right;\n    const computed_bottom = window.innerHeight - bottom;\n    return {\n      top,\n      right: computed_right,\n      bottom: computed_bottom,\n      left\n    };\n  }\n  if (bounds === \"parent\") return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null) throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar set_style = (el, style, value) => el.style.setProperty(style, value);\nvar is_HTMLElement = obj => obj instanceof HTMLElement;\nfunction unwrap_handle_cancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement) return val;\n  if (\"current\" in val) return val.current;\n  if (Array.isArray(val)) {\n    return val.map(v => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const update_ref = useRef();\n  const [isDragging, set_is_dragging] = useState(false);\n  const [dragState, set_drag_state] = useState();\n  let {\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    handle,\n    cancel\n  } = options;\n  let new_handle = unwrap_handle_cancel(handle);\n  let new_cancel = unwrap_handle_cancel(cancel);\n  function call_event(arg, cb) {\n    set_drag_state(arg);\n    cb?.(arg);\n  }\n  function custom_on_drag_start(arg) {\n    set_is_dragging(true);\n    call_event(arg, onDragStart);\n  }\n  function custom_on_drag(arg) {\n    call_event(arg, onDrag);\n  }\n  function custom_on_drag_end(arg) {\n    set_is_dragging(false);\n    call_event(arg, onDragEnd);\n  }\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    const node = nodeRef.current;\n    if (!node) return;\n    ({\n      onDragStart,\n      onDrag,\n      onDragEnd\n    } = options);\n    const {\n      update,\n      destroy\n    } = draggable(node, {\n      ...options,\n      handle: new_handle,\n      cancel: new_cancel,\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n    update_ref.current = update;\n    return destroy;\n  }, []);\n  useEffect(() => {\n    update_ref.current?.({\n      ...options,\n      handle: unwrap_handle_cancel(handle),\n      cancel: unwrap_handle_cancel(cancel),\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n  }, [options]);\n  return {\n    isDragging,\n    dragState\n  };\n}\nexport { useDraggable };","map":{"version":3,"names":["useRef","useState","useEffect","DEFAULT_RECOMPUTE_BOUNDS","dragStart","DEFAULT_DRAG_THRESHOLD","delay","distance","draggable","node","options","bounds","axis","gpuAcceleration","legacyTranslate","transform","applyUserSelectHack","disabled","ignoreMultitouch","recomputeBounds","grid","threshold","position","cancel","handle","defaultClass","defaultClassDragging","defaultClassDragged","defaultPosition","x","y","onDragStart","onDrag","onDragEnd","is_interacting","is_dragging","start_time","meets_time_threshold","meets_distance_threshold","translate_x","translate_y","initial_x","initial_y","client_to_node_offsetX","client_to_node_offsetY","x_offset","y_offset","set_translate","can_move_in_x","can_move_in_y","body_original_user_select_val","computed_bounds","node_rect","drag_els","cancel_els","currently_dragged_el","is_controlled","active_pointers","Set","try_start_drag","event","fire_svelte_drag_start_event","node_class_list","add","body_style","userSelect","reset_state","document","body","style","classList","x_pos","y_pos","common","set_style","transform_called","offsetX","offsetY","rootNode","is_string","get_event_data","currentNode","call_event","eventName","fn","data","dispatchEvent","CustomEvent","detail","fire_svelte_drag_end_event","fire_svelte_drag_event","listen","addEventListener","controller","AbortController","event_options","signal","capture","e","button","pointerId","size","preventDefault","compute_bound_rect","Error","get_handle_els","get_cancel_elements","test","cancel_element_contains","event_target","composedPath","some","el","contains","shadowRoot","length","find","Date","now","getBoundingClientRect","clientX","clientY","inverse_scale","calculate_inverse_scale","left","top","elapsed","delta_x","delta_y","Math","sqrt","drag","final_x","final_y","virtual_client_bounds","right","width","bottom","height","clamp","Array","isArray","x_snap","y_snap","isNaN","snap_to_grid","round","delete","e2","stopPropagation","once","dragEnd","remove","offsetWidth","destroy","abort","update","options2","dragged","val","min","max","pending_x","pending_y","calc","snap","ceil","is_HTMLElement","handle_els","querySelectorAll","from","values","cancel_elements","drag_elements","cancelEl","computed_right","window","innerWidth","computed_bottom","innerHeight","parentNode","querySelector","value","setProperty","obj","HTMLElement","unwrap_handle_cancel","current","map","v","useDraggable","nodeRef","update_ref","isDragging","set_is_dragging","dragState","set_drag_state","new_handle","new_cancel","arg","cb","custom_on_drag_start","custom_on_drag","custom_on_drag_end"],"sources":["/Users/jin.choi/genie95/node_modules/@neodrag/react/dist/index.js"],"sourcesContent":["import { useRef, useState, useEffect } from 'react';\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar DEFAULT_DRAG_THRESHOLD = {\n  delay: 0,\n  distance: 3\n  /* DISTANCE */\n};\nfunction draggable(node, options = {}) {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = false,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    threshold = DEFAULT_DRAG_THRESHOLD,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let is_interacting = false;\n  let is_dragging = false;\n  let start_time = 0;\n  let meets_time_threshold = false;\n  let meets_distance_threshold = false;\n  let translate_x = 0, translate_y = 0;\n  let initial_x = 0, initial_y = 0;\n  let client_to_node_offsetX = 0, client_to_node_offsetY = 0;\n  let { x: x_offset, y: y_offset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  set_translate(x_offset, y_offset);\n  let can_move_in_x;\n  let can_move_in_y;\n  let body_original_user_select_val = \"\";\n  let computed_bounds;\n  let node_rect;\n  let drag_els;\n  let cancel_els;\n  let currently_dragged_el;\n  let is_controlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  threshold = { ...DEFAULT_DRAG_THRESHOLD, ...threshold ?? {} };\n  let active_pointers = /* @__PURE__ */ new Set();\n  function try_start_drag(event) {\n    if (is_interacting && !is_dragging && meets_distance_threshold && meets_time_threshold && currently_dragged_el) {\n      is_dragging = true;\n      fire_svelte_drag_start_event(event);\n      node_class_list.add(defaultClassDragging);\n      if (applyUserSelectHack) {\n        body_original_user_select_val = body_style.userSelect;\n        body_style.userSelect = \"none\";\n      }\n    }\n  }\n  function reset_state() {\n    is_dragging = false;\n    meets_time_threshold = false;\n    meets_distance_threshold = false;\n  }\n  const body_style = document.body.style;\n  const node_class_list = node.classList;\n  function set_translate(x_pos = translate_x, y_pos = translate_y) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+x_pos}px, ${+y_pos}px`;\n        return set_style(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return set_style(node, \"translate\", `${+x_pos}px ${+y_pos}px`);\n    }\n    const transform_called = transform({ offsetX: x_pos, offsetY: y_pos, rootNode: node });\n    if (is_string(transform_called)) {\n      set_style(node, \"transform\", transform_called);\n    }\n  }\n  function get_event_data(event) {\n    return {\n      offsetX: translate_x,\n      offsetY: translate_y,\n      rootNode: node,\n      currentNode: currently_dragged_el,\n      event\n    };\n  }\n  function call_event(eventName, fn, event) {\n    const data = get_event_data(event);\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  }\n  function fire_svelte_drag_start_event(event) {\n    call_event(\"neodrag:start\", onDragStart, event);\n  }\n  function fire_svelte_drag_end_event(event) {\n    call_event(\"neodrag:end\", onDragEnd, event);\n  }\n  function fire_svelte_drag_event(event) {\n    call_event(\"neodrag\", onDrag, event);\n  }\n  const listen = addEventListener;\n  const controller = new AbortController();\n  const event_options = { signal: controller.signal, capture: false };\n  set_style(node, \"touch-action\", \"none\");\n  listen(\n    \"pointerdown\",\n    (e) => {\n      if (disabled) return;\n      if (e.button === 2) return;\n      active_pointers.add(e.pointerId);\n      if (ignoreMultitouch && active_pointers.size > 1) return e.preventDefault();\n      if (recomputeBounds.dragStart) computed_bounds = compute_bound_rect(bounds, node);\n      if (is_string(handle) && is_string(cancel) && handle === cancel)\n        throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n      node_class_list.add(defaultClass);\n      drag_els = get_handle_els(handle, node);\n      cancel_els = get_cancel_elements(cancel, node);\n      can_move_in_x = /(both|x)/.test(axis);\n      can_move_in_y = /(both|y)/.test(axis);\n      if (cancel_element_contains(cancel_els, drag_els))\n        throw new Error(\n          \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n        );\n      const event_target = e.composedPath()[0];\n      if (drag_els.some((el) => el.contains(event_target) || el.shadowRoot?.contains(event_target)) && !cancel_element_contains(cancel_els, [event_target])) {\n        currently_dragged_el = drag_els.length === 1 ? node : drag_els.find((el) => el.contains(event_target));\n        is_interacting = true;\n        start_time = Date.now();\n        if (!threshold.delay) {\n          meets_time_threshold = true;\n        }\n      } else return;\n      node_rect = node.getBoundingClientRect();\n      const { clientX, clientY } = e;\n      const inverse_scale = calculate_inverse_scale();\n      if (can_move_in_x) initial_x = clientX - x_offset / inverse_scale;\n      if (can_move_in_y) initial_y = clientY - y_offset / inverse_scale;\n      if (computed_bounds) {\n        client_to_node_offsetX = clientX - node_rect.left;\n        client_to_node_offsetY = clientY - node_rect.top;\n      }\n    },\n    event_options\n  );\n  listen(\n    \"pointermove\",\n    (e) => {\n      if (!is_interacting || ignoreMultitouch && active_pointers.size > 1) return;\n      if (!is_dragging) {\n        if (!meets_time_threshold) {\n          const elapsed = Date.now() - start_time;\n          if (elapsed >= threshold.delay) {\n            meets_time_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!meets_distance_threshold) {\n          const delta_x = e.clientX - initial_x;\n          const delta_y = e.clientY - initial_y;\n          const distance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n          if (distance >= threshold.distance) {\n            meets_distance_threshold = true;\n            try_start_drag(e);\n          }\n        }\n        if (!is_dragging) return;\n      }\n      if (recomputeBounds.drag) computed_bounds = compute_bound_rect(bounds, node);\n      e.preventDefault();\n      node_rect = node.getBoundingClientRect();\n      let final_x = e.clientX, final_y = e.clientY;\n      const inverse_scale = calculate_inverse_scale();\n      if (computed_bounds) {\n        const virtual_client_bounds = {\n          left: computed_bounds.left + client_to_node_offsetX,\n          top: computed_bounds.top + client_to_node_offsetY,\n          right: computed_bounds.right + client_to_node_offsetX - node_rect.width,\n          bottom: computed_bounds.bottom + client_to_node_offsetY - node_rect.height\n        };\n        final_x = clamp(final_x, virtual_client_bounds.left, virtual_client_bounds.right);\n        final_y = clamp(final_y, virtual_client_bounds.top, virtual_client_bounds.bottom);\n      }\n      if (Array.isArray(grid)) {\n        let [x_snap, y_snap] = grid;\n        if (isNaN(+x_snap) || x_snap < 0)\n          throw new Error(\"1st argument of `grid` must be a valid positive number\");\n        if (isNaN(+y_snap) || y_snap < 0)\n          throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n        let delta_x = final_x - initial_x, delta_y = final_y - initial_y;\n        [delta_x, delta_y] = snap_to_grid(\n          [x_snap / inverse_scale, y_snap / inverse_scale],\n          delta_x,\n          delta_y\n        );\n        final_x = initial_x + delta_x;\n        final_y = initial_y + delta_y;\n      }\n      if (can_move_in_x) translate_x = Math.round((final_x - initial_x) * inverse_scale);\n      if (can_move_in_y) translate_y = Math.round((final_y - initial_y) * inverse_scale);\n      x_offset = translate_x;\n      y_offset = translate_y;\n      fire_svelte_drag_event(e);\n      set_translate();\n    },\n    event_options\n  );\n  listen(\n    \"pointerup\",\n    (e) => {\n      active_pointers.delete(e.pointerId);\n      if (!is_interacting) return;\n      if (is_dragging) {\n        listen(\"click\", (e2) => e2.stopPropagation(), {\n          once: true,\n          signal: controller.signal,\n          capture: true\n        });\n        if (recomputeBounds.dragEnd) computed_bounds = compute_bound_rect(bounds, node);\n        node_class_list.remove(defaultClassDragging);\n        node_class_list.add(defaultClassDragged);\n        if (applyUserSelectHack) body_style.userSelect = body_original_user_select_val;\n        fire_svelte_drag_end_event(e);\n        if (can_move_in_x) initial_x = translate_x;\n        if (can_move_in_y) initial_y = translate_y;\n      }\n      is_interacting = false;\n      reset_state();\n    },\n    event_options\n  );\n  function calculate_inverse_scale() {\n    let inverse_scale = node.offsetWidth / node_rect.width;\n    if (isNaN(inverse_scale)) inverse_scale = 1;\n    return inverse_scale;\n  }\n  return {\n    destroy: () => controller.abort(),\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? true;\n      transform = options2.transform;\n      threshold = { ...DEFAULT_DRAG_THRESHOLD, ...options2.threshold ?? {} };\n      const dragged = node_class_list.contains(defaultClassDragged);\n      node_class_list.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      node_class_list.add(defaultClass);\n      if (dragged) node_class_list.add(defaultClassDragged);\n      if (is_controlled) {\n        x_offset = translate_x = options2.position?.x ?? translate_x;\n        y_offset = translate_y = options2.position?.y ?? translate_y;\n        set_translate();\n      }\n    }\n  };\n}\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar is_string = (val) => typeof val === \"string\";\nvar snap_to_grid = ([x_snap, y_snap], pending_x, pending_y) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pending_x, x_snap);\n  const y = calc(pending_y, y_snap);\n  return [x, y];\n};\nfunction get_handle_els(handle, node) {\n  if (!handle) return [node];\n  if (is_HTMLElement(handle)) return [handle];\n  if (Array.isArray(handle)) return handle;\n  const handle_els = node.querySelectorAll(handle);\n  if (handle_els === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handle_els.values());\n}\nfunction get_cancel_elements(cancel, node) {\n  if (!cancel) return [];\n  if (is_HTMLElement(cancel)) return [cancel];\n  if (Array.isArray(cancel)) return cancel;\n  const cancel_els = node.querySelectorAll(cancel);\n  if (cancel_els === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancel_els.values());\n}\nvar cancel_element_contains = (cancel_elements, drag_elements) => cancel_elements.some((cancelEl) => drag_elements.some((el) => cancelEl.contains(el)));\nfunction compute_bound_rect(bounds, rootNode) {\n  if (bounds === void 0) return;\n  if (is_HTMLElement(bounds)) return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computed_right = window.innerWidth - right;\n    const computed_bottom = window.innerHeight - bottom;\n    return { top, right: computed_right, bottom: computed_bottom, left };\n  }\n  if (bounds === \"parent\") return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar set_style = (el, style, value) => el.style.setProperty(style, value);\nvar is_HTMLElement = (obj) => obj instanceof HTMLElement;\nfunction unwrap_handle_cancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement) return val;\n  if (\"current\" in val) return val.current;\n  if (Array.isArray(val)) {\n    return val.map((v) => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const update_ref = useRef();\n  const [isDragging, set_is_dragging] = useState(false);\n  const [dragState, set_drag_state] = useState();\n  let { onDragStart, onDrag, onDragEnd, handle, cancel } = options;\n  let new_handle = unwrap_handle_cancel(handle);\n  let new_cancel = unwrap_handle_cancel(cancel);\n  function call_event(arg, cb) {\n    set_drag_state(arg);\n    cb?.(arg);\n  }\n  function custom_on_drag_start(arg) {\n    set_is_dragging(true);\n    call_event(arg, onDragStart);\n  }\n  function custom_on_drag(arg) {\n    call_event(arg, onDrag);\n  }\n  function custom_on_drag_end(arg) {\n    set_is_dragging(false);\n    call_event(arg, onDragEnd);\n  }\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    const node = nodeRef.current;\n    if (!node) return;\n    ({ onDragStart, onDrag, onDragEnd } = options);\n    const { update, destroy } = draggable(node, {\n      ...options,\n      handle: new_handle,\n      cancel: new_cancel,\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n    update_ref.current = update;\n    return destroy;\n  }, []);\n  useEffect(() => {\n    update_ref.current?.({\n      ...options,\n      handle: unwrap_handle_cancel(handle),\n      cancel: unwrap_handle_cancel(cancel),\n      onDragStart: custom_on_drag_start,\n      onDrag: custom_on_drag,\n      onDragEnd: custom_on_drag_end\n    });\n  }, [options]);\n  return { isDragging, dragState };\n}\n\nexport { useDraggable };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}